# Viewstamped Replication Revisited

## 摘要

> 这篇论文阐述了一个改进版本的 Viewstamped Replication 算法，既一种可以在节点崩溃的时候来处理错误的备份技术。本文描述了客户端请求是怎样被处理的，当备份失败的时候，集群是怎样重新组织的，以及怎样能使出错的副本机重新加入集群。同时，这篇论文还描述了很多优化以及一个协议，来改变集群成员和集群可以容纳的错误节点数量。

## 1. 介绍

本文呈现了一个改进版本的 Viewstamped Replication 算法（后文称作 VR）。VR 工作在异步网络中，比如 Internet ，用来处理节点崩溃所导致的错误。它支持一个运行在很多备份节点上的复制服务。这个服务维护一个可以被很多客户机访问的状态。VR 提供了复制状态机：客户端可以执行通用的操作来观察和修改服务的状态。因此这个算法可以用于实现诸如锁管理或者文件系统这样的复制服务。



本文的阐述和之前的 VR 论文有以下几个区别：

- 本文描述的协议是原始的 VR 协议的增强版本：这个协议更加简洁，而且效率更高。其中一些改进受到了关于拜占庭容错问题研究的启发。
- 这个协议不会要求任何磁盘的使用，取而代之的是使用复制状态来提供持久化。
- 本文展示了一个重新配置协议，这个协议允许变更备份集群中的成员，例如，可以将集群中出错的节点替换成新的机器。
- 文中阐述的协议独立与任何 VR 应用。原始版本的论文中阐述的协议是一个数据库或者文件系统的一部分。这使得将协议从复杂的应用细节中分离变得很困难。

VR 最初在 1980 年代被开发出来，这和 Paxos 被发明的时间几乎相同。但是 VR 的研究与 Paxos 是独立不相关的。它与 Paxos 的一个区别在于，VR 是一个复制协议，而 Paxos 是一个一致性协议：VR 使用了一个和 Paxos 非常类似的一致性协议来支持一个复制状态机。另一个与 Paxos 的不同点是，VR 中用来执行状态机操作的一致性协议并不需要磁盘 I/O 操作。



一些关于 VR 历史的信息可以在 [7] 中找到。这篇论文的内容是一个相似但是不完善的 VR 的描述。它也解释了VR是如何影响后续关于拜占庭容错问题的工作，以及那些协议与 VR 之间的关系。



本文剩余的部分安排了以下内容：第 2 节提供了一些背景材料；第 3 节概述了实现的方式；第 4 节描述了 VR 协议；第 5 节描述了很多用于提高性能的实现细节；第 6 节讨论了很多可以进一步提升性能的优化方案；第 7 节描述了我们的重配置（reconfiguration）协议；第 8 节讨论了 VR 的正确性；第 9 节也就是最后一节对全文进行总结。



## 2. 背景

这一节以讨论我们假设的 VR 工作环境开始。2.2 节讨论了为保障正确行为所需要的最少副本机（replica）数量；2.3 节描述了怎样配置一个系统来使用 VR。



### 2.1 假设

VR 处理的事崩溃造成的错误：我们假设崩溃是导致节点失效的唯一原因，所以机器本身的功能是正常或者完全停机的。VR 不能处理拜占庭错误，也就是节点可以产生任意情况的失效，像是节点可能被恶意组织攻击而产生有害数据的失效。



VR 的设计初衷是将其用于类似 Internet 的异步网络中，在这种环境下，消息未能送达意味着发送者的状态完全没有变化。可能存在消息丢失（丢包），延迟送达或者顺序混乱，以及被多次送达的情况。这里我们还需要假设如果重复的重发消息，该消息最终一定会被送达。

> 前提：
>
> 1. 消息没有被送达就意味着什么都没改变
> 2. 消息会丢包会混乱会延迟，以及收到多次
> 3. 重复发送消息，该消息最终一定会送达

在本文中，我们假设网络是不会被恶意攻击的，也就意味着消息是不会被伪造的。如果需要考虑这样的攻击，我们可以使用加密通信来避免它们。



## 2.2 复制集群

当集群拥有 `2f+1` 台副本机时，VR 可以保证其中不超过 `f` 台副本机出现故障的时候，系统依然可靠和可用。在这个崩溃失效模型下，这个是集群中节点的最少数量。下面将会阐述需要这么多设备的原因：



我们必须能够在无需等待 `f` 台副本机参与的情况下进行一个请求，因为这些副本机可能已经崩溃并且不能响应。然而这 `f` 台我们没有收到过消息的副本机可能仅仅是因为太慢而无法响应，例如网络的拥塞就会导致这个情况出现。我们收到消息的 `f` 台机器可能随后也会因此失效，因此我们需要足够数量的副本机来运行这个协议，以此来保证就算 `f` 台机器失效了，我们仍然有至少一个副本机知道我们有这个需要处理的请求。这也意味着这个协议的每个步骤都**必须**由`f+1`台副本机处理，这些 `f+1` 台机器和另外不响应的 `f` 台机器加在一起组成了最小的机器数量也就是 `2f+1`。



一个 `f+1` 台机器组成的一个机器集合经常被称为 `quorum` ，协议的正确性依赖于 `quorum intersection property`：集群中处理协议中的一个特定步骤的 `quorum` 必须与集群中可以处理下一个步骤的机器的集合有一个非空的交集。这样我们就可以保证在每个下一步的操作中，至少有一台机器知道在上一步发生了什么事。再一个由 `2f+1` 台机器组成的集群中，`f+1` 是组成一个可以正常运作的  `quorum` 的最小数量。



总而言之，一个集群不需要一定有 `2f+1` 台机器，如果没有这么多机器的话，这个阈值就是令 `2f+1 ≤ 机器总数K` 成立的最大的 `f` 值，而 `quorum` 的数量就是 `K - f`。然而，对一个特定的阈值 `f` 而言，大于 `2f+1` 台机器的集群并不会带来优势，因为更大的集群需要更大数量的 `quorum` 来保证交集，但这并不能提升系统的容错性能。因此在本文中协议描述的部分均假设集群的大小为准确的 `2f+1` 。



> f 台机器失效后，系统正常运行的必要条件
>
> 1. 系统中必须有 2f + 1 台机器
> 2. 每个请求都必须由 f + 1 台机器处理
> 3. A: quorum B: 可以处理下一步骤的机器集合 A ^ B = ø

> 更多的机器数量对集群容错性能的提高无益



![image-20200924201757910](/Users/qingshuihe/Library/Application Support/typora-user-images/image-20200924201757910.png)

​																图1：VR 架构；图中展示了 f=1 时的配置



### 2.3 架构

图1 中展示了运行 VR 协议的架构。这个图展示了一些使用了 VR 的客户机，他们运行在 3 台副本机上；因此在这个例子中 `f = 1`。客户机在 VR Proxy 上层运行客户代码。客户代码通过向 proxy 发送调用操作与 VR 通讯。proxy 继而将调用操作转发给上层的副本机，服务端的代码将执行这些调用并且将结果返回给 VR 代码，再由 VR 转发这些消息给发起这些调用的客户端 proxy。

在这 `2f+1` 台副本机中，只有 `f+1` 台需要运行服务端代码，我们将在 6.1 节讨论这个观点。



### 3. 概览

状态机复制要求副本机们以**相同的初始化状态**启动，而且操作必须是确定性的。在这写假设条件下，很容易理解如果副本机执行的操作序列完全相同，他们将会以相同的状态终止。这个对于复制协议的挑战在于要确保所有的操作需要在所有副本机上按照完全相同的顺序执行，尽管这些请求是并发的而且是有可能会失败的。

VR 使用了一个主（primary）副本机排序请求；其他副本机都是备份机器，他们只是简单地按照主机排好的顺序接受请求。主机的使用提供了一个简单地解决方案来满足顺序要求，但是这也带来一个新的问题：如果主机挂了会发生什么？VR 对这个问题的解决方案是允许不同的副本机器随着时间的推移来承担主机的角色。系统在一系列的 `views` 中移动。执行每个 view 的时候，都要从所有的副本机器中选取一台作为主机。备份机器监控着主机，如果主机看起来挂了，备份机器们会执行一个 `view change` 协议来选取一个新的主机。

为了让系统在 view change 过程中正确工作，系统在下一个 view 的状态必须能够按照顺序反映在早前的 view 中全部客户机的操作。为了满足这个要求，首先在执行请求之前，我们让主机等待直到有至少 `f+1` 台副本机（包括主机自己）了解到这个客户端请求，同时还要通过向至少 `f+1` 台副本机查询来初始化新 view 的状态。因此每个请求都被 quorum 了解，而且新的 view 从 quorum 中开始。

 

> 这一部分的思路：
>
> 1. 需要解决请求的顺序问题，请求可能是并发的而且会有失败的可能，怎么保证顺序？
>
> 2. 用主机来排序解决 1，那么主机挂了怎么办
> 3. 备份机监视主机，主机挂了的话就从备份机器里面选一台作为主机，这解决了 2，但是交接过程中也要保证没有问题，怎么办？
> 4. 让主机等到 f+1 台机器都知道请求，并且从 f+1 台机器中查询来初始化新的 view 状态



VR 也为节点无法恢复正常时系统继续处理请求提供了解决方案。这很重要，否则失效节点的数量最终会超过阈值。正确地恢复要求正在恢复的副本机只能在当它知道距离它失效时间最近的状态时，它才能重新加入协议中，这样它才在 quorum 需要的时候正确地响应。很显然，只要副本机在每次通讯之前就将它所知道的信息记录在磁盘上，就可以满足这个要求。然而我们不要求使用磁盘来达到这个目的（VR 的原始版本也不需要磁盘）。

因此，VR 使用三个子协议协同工作来保证正确性。

- 正常情况下处理用户的请求
- View changes 来选择新的主机
- 恢复失效的副本机器来让它重新加入集群

这些子协议将在下一节中描述。









































































