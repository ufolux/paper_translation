# Viewstamped Replication Revisited

## 摘要

> 这篇论文阐述了一个改进版本的 Viewstamped Replication 算法，既一种可以在节点崩溃的时候来处理错误的备份技术。本文描述了客户端请求是怎样被处理的，当备份失败的时候，集群是怎样重新组织的，以及怎样能使出错的副本机重新加入集群。同时，这篇论文还描述了很多优化以及一个协议，来改变集群成员和集群可以容纳的错误节点数量。

## 1. 介绍

本文呈现了一个改进版本的 Viewstamped Replication 算法（后文称作 VR）。VR 工作在异步网络中，比如 Internet ，用来处理节点崩溃所导致的错误。它支持一个运行在很多备份节点上的复制服务。这个服务维护一个可以被很多客户机访问的状态。VR 提供了复制状态机：客户端可以执行通用的操作来观察和修改服务的状态。因此这个算法可以用于实现诸如锁管理或者文件系统这样的复制服务。



本文的阐述和之前的 VR 论文有以下几个区别：

- 本文描述的协议是原始的 VR 协议的增强版本：这个协议更加简洁，而且效率更高。其中一些改进受到了关于拜占庭容错问题研究的启发。
- 这个协议不会要求任何磁盘的使用，取而代之的是使用复制状态来提供持久化。
- 本文展示了一个重新配置协议，这个协议允许变更备份集群中的成员，例如，可以将集群中出错的节点替换成新的机器。
- 文中阐述的协议独立与任何 VR 应用。原始版本的论文中阐述的协议是一个数据库或者文件系统的一部分。这使得将协议从复杂的应用细节中分离变得很困难。

VR 最初在 1980 年代被开发出来，这和 Paxos 被发明的时间几乎相同。但是 VR 的研究与 Paxos 是独立不相关的。它与 Paxos 的一个区别在于，VR 是一个复制协议，而 Paxos 是一个一致性协议：VR 使用了一个和 Paxos 非常类似的一致性协议来支持一个复制状态机。另一个与 Paxos 的不同点是，VR 中用来执行状态机操作的一致性协议并不需要磁盘 I/O 操作。



一些关于 VR 历史的信息可以在 [7] 中找到。这篇论文的内容是一个相似但是不完善的 VR 的描述。它也解释了VR是如何影响后续关于拜占庭容错问题的工作，以及那些协议与 VR 之间的关系。



本文剩余的部分安排了以下内容：第 2 节提供了一些背景材料；第 3 节概述了实现的方式；第 4 节描述了 VR 协议；第 5 节描述了很多用于提高性能的实现细节；第 6 节讨论了很多可以进一步提升性能的优化方案；第 7 节描述了我们的重配置（reconfiguration）协议；第 8 节讨论了 VR 的正确性；第 9 节也就是最后一节对全文进行总结。



## 2. 背景

这一节以讨论我们假设的 VR 工作环境开始。2.2 节讨论了为保障正确行为所需要的最少副本机（replica）数量；2.3 节描述了怎样配置一个系统来使用 VR。



### 2.1 假设

VR 处理的事崩溃造成的错误：我们假设崩溃是导致节点失效的唯一原因，所以机器本身的功能是正常或者完全停机的。VR 不能处理拜占庭错误，也就是节点可以产生任意情况的失效，像是节点可能被恶意组织攻击而产生有害数据的失效。



VR 的设计初衷是将其用于类似 Internet 的异步网络中，在这种环境下，消息未能送达意味着发送者的状态完全没有变化。可能存在消息丢失（丢包），延迟送达或者顺序混乱，以及被多次送达的情况。这里我们还需要假设如果重复的重发消息，该消息最终一定会被送达。

> 前提：
>
> 1. 消息没有被送达就意味着什么都没改变
> 2. 消息会丢包会混乱会延迟，以及收到多次
> 3. 重复发送消息，该消息最终一定会送达

在本文中，我们假设网络是不会被恶意攻击的，也就意味着消息是不会被伪造的。如果需要考虑这样的攻击，我们可以使用加密通信来避免它们。



### 2.2 复制集群

当集群拥有 `2f+1` 台副本机时，VR 可以保证其中不超过 `f` 台副本机出现故障的时候，系统依然可靠和可用。在这个崩溃失效模型下，这个是集群中节点的最少数量。下面将会阐述需要这么多设备的原因：



我们必须能够在无需等待 `f` 台副本机参与的情况下进行一个请求，因为这些副本机可能已经崩溃并且不能响应。然而这 `f` 台我们没有收到过消息的副本机可能仅仅是因为太慢而无法响应，例如网络的拥塞就会导致这个情况出现。我们收到消息的 `f` 台机器可能随后也会因此失效，因此我们需要足够数量的副本机来运行这个协议，以此来保证就算 `f` 台机器失效了，我们仍然有至少一个副本机知道我们有这个需要处理的请求。这也意味着这个协议的每个步骤都**必须**由`f+1`台副本机处理，这些 `f+1` 台机器和另外不响应的 `f` 台机器加在一起组成了最小的机器数量也就是 `2f+1`。



一个 `f+1` 台机器组成的一个机器集合经常被称为 `quorum` ，协议的正确性依赖于 `quorum intersection property`：集群中处理协议中的一个特定步骤的 `quorum` 必须与集群中可以处理下一个步骤的机器的集合有一个非空的交集。这样我们就可以保证在每个下一步的操作中，至少有一台机器知道在上一步发生了什么事。再一个由 `2f+1` 台机器组成的集群中，`f+1` 是组成一个可以正常运作的  `quorum` 的最小数量。



总而言之，一个集群不需要一定有 `2f+1` 台机器，如果没有这么多机器的话，这个阈值就是令 `2f+1 ≤ 机器总数K` 成立的最大的 `f` 值，而 `quorum` 的数量就是 `K - f`。然而，对一个特定的阈值 `f` 而言，大于 `2f+1` 台机器的集群并不会带来优势，因为更大的集群需要更大数量的 `quorum` 来保证交集，但这并不能提升系统的容错性能。因此在本文中协议描述的部分均假设集群的大小为准确的 `2f+1` 。



> f 台机器失效后，系统正常运行的必要条件
>
> 1. 系统中必须有 2f + 1 台机器
> 2. 每个请求都必须由 f + 1 台机器处理
> 3. A: quorum B: 可以处理下一步骤的机器集合 A ^ B = ø

> 更多的机器数量对集群容错性能的提高无益



![image-20200924201757910](/Users/qingshuihe/Library/Application Support/typora-user-images/image-20200924201757910.png)

​																图1：VR 架构；图中展示了 f=1 时的配置



### 2.3 架构

图1 中展示了运行 VR 协议的架构。这个图展示了一些使用了 VR 的客户机，他们运行在 3 台副本机上；因此在这个例子中 `f = 1`。客户机在 VR Proxy 上层运行客户代码。客户代码通过向 proxy 发送调用操作与 VR 通讯。proxy 继而将调用操作转发给上层的副本机，服务端的代码将执行这些调用并且将结果返回给 VR 代码，再由 VR 转发这些消息给发起这些调用的客户端 proxy。

在这 `2f+1` 台副本机中，只有 `f+1` 台需要运行服务端代码，我们将在 6.1 节讨论这个观点。



## 3. 概览

状态机复制要求副本机们以**相同的初始化状态**启动，而且操作必须是确定性的。在这写假设条件下，很容易理解如果副本机执行的操作序列完全相同，他们将会以相同的状态终止。这个对于复制协议的挑战在于要确保所有的操作需要在所有副本机上按照完全相同的顺序执行，尽管这些请求是并发的而且是有可能会失败的。

VR 使用了一个主（primary）副本机排序请求；其他副本机都是备份机器，他们只是简单地按照主机排好的顺序接受请求。主机的使用提供了一个简单地解决方案来满足顺序要求，但是这也带来一个新的问题：如果主机挂了会发生什么？VR 对这个问题的解决方案是允许不同的副本机器随着时间的推移来承担主机的角色。系统在一系列的 `views` 中移动。执行每个 view 的时候，都要从所有的副本机器中选取一台作为主机。备份机器监控着主机，如果主机看起来挂了，备份机器们会执行一个 `view change` 协议来选取一个新的主机。

为了让系统在 view change 过程中正确工作，系统在下一个 view 的状态必须能够按照顺序反映在早前的 view 中全部客户机的操作。为了满足这个要求，首先在执行请求之前，我们让主机等待直到有至少 `f+1` 台副本机（包括主机自己）了解到这个客户端请求，同时还要通过向至少 `f+1` 台副本机查询来初始化新 view 的状态。因此每个请求都被 quorum 了解，而且新的 view 从 quorum 中开始。

 

> 这一部分的思路：
>
> 1. 需要解决请求的顺序问题，请求可能是并发的而且会有失败的可能，怎么保证顺序？
>
> 2. 用主机来排序解决 1，那么主机挂了怎么办
> 3. 备份机监视主机，主机挂了的话就从备份机器里面选一台作为主机，这解决了 2，但是交接过程中也要保证没有问题，怎么办？
> 4. 让主机等到 f+1 台机器都知道请求，并且从 f+1 台机器中查询来初始化新的 view 状态



VR 也为节点无法恢复正常时系统继续处理请求提供了解决方案。这很重要，否则失效节点的数量最终会超过阈值。正确地恢复要求正在恢复的副本机只能在当它知道距离它失效时间最近的状态时，它才能重新加入协议中，这样它才在 quorum 需要的时候正确地响应。很显然，只要副本机在每次通讯之前就将它所知道的信息记录在磁盘上，就可以满足这个要求。然而我们不要求使用磁盘来达到这个目的（VR 的原始版本也不需要磁盘）。

因此，VR 使用三个子协议协同工作来保证正确性。

- 正常情况下处理用户的请求
- View changes 来选择新的主机
- 恢复失效的副本机器来让它重新加入集群

这些子协议将在下一节中描述。



## 4. VR 协议

这一节描述了假设我们的集群是固定的， VR 是如何在这个条件下工作的。在第 5 节我们讨论了一些方式来改善协议的性能。在第 6 节讲述了一些优化的方式。在第 7 节阐述了重配置（reconfiguration）协议的工作原理，这个协议可以允许副本机集群发生变化。



​																					下面是图表 2：

- 配置（configuration）是一个保存着这 `2f+1` 台副本机器 IP 地址的有序数组。
- 副本机号（replica number）是副本机在配置中的位置编号。
- 当前 view 号（view-number），初始值是 0。
- 当前状态（status)，值是 `normal`, `view-change`, `recovering` 之一。
- op-number 是分配给最近收到的请求的编号，初始值为 0。
- 日志（log）是一个保存了 op-number 条目的数组。这些条目包含了迄今为止收到的所有请求，这些请求按照顺序排列。
- 提交编号（commit-number）是最近一个提交操作的 `op-number`。
- 客户端表（client-table）记录着客户端最近发起的请求编号，另外，如果这个请求已经被执行了，执行的结果会响应对应的请求。





图表 2 展示了副本机 VR 层的状态。 可以看到主机的身份并没有被记录在状态中，这个状态是通过 `view-number`和 `configuration` 计算得到的。我们根据副本机的 IP 地址将副本机们编号：IP 地址最小的副本机被标记为 1 号。主机会从副本机器中轮训产生，从 1 号开始。当系统转移到一个新 views 时，状态（status）会标明副本机当前执行的是哪一个子协议（sub-protocol）。

> 主机 = 配置数组[view-number]
>
> 所以 view-number 就是当前的主机在配置数组中的 index



客户端代理同样也是状态（state）。它记录了配置（configuration）和它认为正确的当前 view-number，这让它知道哪一个机器是当前的主机。每个发送给客户端的消息都通知它当前的 view-number 是多少，这让客户端可以时刻跟踪主机。

> 客户端代理通过记录当前 view-number 来得知当前的主机是谁



另外，客户端记录了他自己的客户端 id（client-id）和一个当前的请求编号（request-number）。一个客户端同时只能允许发起一个请求。每个请求都会被客户端编号，后发起的请求编号要大于先发起的请求；我们将在 4.5 节讨论当客户端失效并恢复时改如何保证这一点。副本机器用请求的编号来避免多次执行同一个请求；客户端也是用这个编号来丢弃对同一请求的重复响应。



> 编号是用来防止重复执行请求和获取响应数据的



### 4.1 正常操作（Normal Operation）

本节中描述了 VR 在主机失效的情况下是如何工作的。副本机只有在他们的状态（status）是正常（normal）的情况下才会参与到对客户端请求的处理过程中。这对第 8 节中所讨论的正确性而言是至关重要的。

协议描述假设所有参与的副本机都处在同一个 view 中。副本机向对方发出的每个消息都包含了副本机当前的 view-number。副本机只处理那些正常协议（normal protocol）下的包含了该副本机已知 view-number 的消息。如果发送者落后了，副本机将会抛弃这个消息。如果发送者提前了，副本机将会发起一个状态（state）转移。它将会请求那些它从其他副本机器那里丢掉的消息，并且利用这些消息更新自己的状态，然后再处理消息。在 5.2 节我们将会讨论状态（state）转移。



下面来讲一下请求处理协议（request prcessing protocol） 的工作方式，这个描述忽略了很多次要的细节，例如：重发（re-sending）那些没有收到响应的协议信息。

1. 客户端发送了一个 `<Request op, c, s>` 信息给主机。op 是客户端想要执行的操作（带有参数的），c 是客户端 id （client-id），s 是请求的编号。
2. 当主机接收到请求时，它会将请求的编号和客户端表（client-table）中的信息进行比较。如果请求编号不大于客户端表中记录的信息。主机将会丢弃这个请求，但是如果这个请求是这个客户端上最新的一个请求，且这个请求已经被执行了的话，主机还是会重新发送响应。
3. 主机将 `op-number` 增加，将请求添加到 `log` 的末尾，同时更新客户端表中该客户端的信息，让它包含最新的请求号（request-number）`s`，然后它发送了一个 `<Prepare v, m, n, k>` 消息给其他的副本机器。`v` 是当前的 view-number， `m` 是从客户端接收的消息， `n` 是指派给请求的 `op-number`， `k`是一个提交号（commit-number）。
4. 备份机器按顺序处理 Prepare 消息：除非一个 `op-number` 为 `n` 的 Prepare 消息的日志（log）中包含全部先前请求的条目，备份机器不会接受这个 Prepare 消息。当备机 `i`接受了一个 Prepare 消息，他将持续等待，直到它的日志条目中包含了先前的全部请求信息（为了获取丢失的信息，必要的情况下会实施状态转移）。然后增加它的 `op-number`，将请求添加到它日志的末尾，更新客户端表中客户端的信息，同时发送一个 `<PrepareOk v, n, i>` 消息给主机标记这个操作以及先前的所有操作都已经在本地准备完成。
5. 主机等待 `f` 个不同的备机发来 PrepareOk 消息；这时主机认为这个操作和之前所有的操作都已经被提交（commited），然后，在它已经执行了所有先前的操作之后（那些 `op-number` 较小的操作），主机通过向上层的服务端代码发起请求来执行操作，同时增加它的 `commit-number`. 之后它发送一个 `<Reply, v, s, x>` 消息给客户端；`v` 表示 view-number， `s` 是客户端带在请求中的一个数字，`x` 是上层调用返回的结果。主机也更新了客户端表中客户端的条目，将结果添加到其所在条目中。
6. 一般而言，主机会在它发送下一次 Prepare 消息的时候通知所有备机关于提交（commit）的信息。这就是 Prepare 消息中 commit-number 的作用。然而如果主机在一段时间内没有收到客户端的新请求，它会将最新的一个提交通知备机，通过发送一个 `<Commit, v, k>` 消息，`k` 是 commit-number（注意在这个情况下，commit-number = op-number）。
7. 当一个备机了解到一个提交的时候，他将一直等待，直它他的日志中存在请求（这可能需要状态转移）并且它执行完了先前的全部请求。之后，它通过调用上层服务的代码来执行操作。递增它的 commit-number，更新客户端表中的该客户端的条目，但是不发送 Reply 消息给客户端。



![image-20200925154410649](/Users/qingshuihe/Library/Application Support/typora-user-images/image-20200925154410649.png)

​														图表 3 正常情况下的 VR 处理过程，其中 f = 1



图表 3 展示了正常处理协议的各个阶段。

如果一个客户端在一定时间内没有接受到某个请求的响应，它将会向所有副本机重新发送请求。这样的话，如果集群已经转移到新的 view，这个消息将会被送达到新的主机那里。备份机将忽略客户端的这个请求，主机会处理它们。

在第 3 步协议可以被修改为允许备份机乱序处理 Prepare 消息。然而这并不会带来什么好处，反而还让view change 协议变得复杂化。因此，备机应该按照 `op-number` 顺序处理 Prepare 消息。

协议不需要任何的磁盘写入，例如，当它们在 log 中添加操作的时候，副本机不需要在磁盘写入 log。这一点将在 4.3 节中讨论。

上述的协议快速地备份了正在执行的操作：提交的信息传播的非常迅速，而且备机也会尽可能快的执行操作。也许我们可以采用比较偷懒的实现方式，但是重要的是备份不要落后太多。原因是当 view change 发生的时候，变成主机的副本机将无法执行新的客户端请求，直到它被更新到最新状态。如果能够迅速地执行操作，我们就可以保证当备机取代主机的时候，它还是可以以很低的延迟来处理客户端的新请求。



### 4.2 View Changes

View changes 用于屏蔽主机的失效。

备机监视着主机：它们期望能从主机获得正常的信息。一般而言，主机一直在发送 Prepare 消息，但是如果主机空闲下来（因为没有新的请求）它将会转而发送 Commit 消息。如果主机在没有沟通的情况下超时了，其他副本机们将会发起一次 view change 来切换到新的主机。



视图更改的正确性条件是，通过向上调用其中一个副本的服务代码执行的每个操作都必须保留以在该 view 中选择的相同顺序进入新 view 执行。


